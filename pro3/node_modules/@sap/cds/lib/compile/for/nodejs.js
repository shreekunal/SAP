const { unfold_csn } = require ('../etc/_localized')
const cds = require ('../../index')
const TRACE = cds.debug('trace')


function _compile_for_nodejs (csn, o) {
  let min = cds.minify (csn)
  let dsn = cds.compile.for.odata(min, o) //> creates a partial copy -> avoid any cds.linked() before
  dsn = unfold_csn(dsn)
  dsn = cds.linked(dsn)
  cds.compile.for.lean_drafts(dsn)

  // @Common.Text â†’ @cds.search
  text_to_search: for (const name in dsn.definitions) {
    const def = dsn.definitions[name]
    if (!def.associations) continue

    // if any @cds.search.* === true, @Common.Text should be ignored
    for (const key in def) if (key.startsWith('@cds.search') && def[key]) continue text_to_search

    let isSearchAddedProgrammatically = false

    // Add elements referenced in common.text annotations to search-relevant elements
    for (const name in def.associations) {
      const assoc = def.associations[name]

      // Extract the reference value from the @Common.Text annotation
      let annotationValue = assoc['@Common.Text']
      if (!annotationValue) continue

      // Extract the relevant label reference
      let commonTextRef = annotationValue.ref
      if (!commonTextRef) commonTextRef = annotationValue['='].split('.')

      // Ignore empty references & those with more than two segments
      if (commonTextRef.length < 1 || commonTextRef.length > 2) continue
      
      // Make sure the reference is not explicitly excluded from search
      const commonTextValue = commonTextRef.join('.')
      if (def[`@cds.search.${commonTextValue}`] === false) continue

      if (commonTextRef.length === 1) {
        const element = def.elements[commonTextRef[0]]
        if (!element || element.target || element.items) continue
      }

      if (commonTextRef.length === 2) {
        const association = def.associations[commonTextRef[0]]
        if (!association) continue
        
        const associationTarget = dsn.definitions[association.target]
        if (!associationTarget) continue
        if (associationTarget['@cds.persistence.skip']) continue

        const element = associationTarget.elements[commonTextRef[1]]
        if (!element || element.target || element.items) continue
      }

      def[`@cds.search.${commonTextValue}`] = true
      isSearchAddedProgrammatically = true
    }

    // add all string elements to @cds.search, if not annotated with @cds.search = false
    if (isSearchAddedProgrammatically)
      for (const el in def.elements) {
        const search_el = def.elements[el]
        if (search_el._type === 'cds.String' && def[`@cds.search.${search_el.name}`] !== false) {
          def[`@cds.search.${search_el.name}`] = true
        }
      }
  }

  Object.defineProperty(csn, '_4nodejs', { value: dsn })
  Object.defineProperty(dsn, '_4nodejs', { value: dsn })
  Object.assign (dsn.meta, csn.meta, dsn.meta) // merge meta data, as it may have been enhanced
  return dsn
}


module.exports = function cds_compile_for_nodejs (csn,o) {
  if ('_4nodejs' in csn) return csn._4nodejs
  // REVISIT: remove _compat_texts_entities with cds^10
  if (cds.env.features.compat_texts_entities) Object.defineProperty(csn, '_compat_texts_entities', { value: true, enumerable: true })
  TRACE?.time('cds.compile 4nodejs'.padEnd(22)); try {
    let result, next = ()=> result ??= _compile_for_nodejs (csn,o)
    cds.emit ('compile.for.runtime', csn, o, next)
    return next() //> in case no handler called next
  }
  finally { TRACE?.timeEnd('cds.compile 4nodejs'.padEnd(22)) }
}
