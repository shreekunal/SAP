const cds = require('../cds')
const { exists, isdir } = cds.utils
const BuildTaskEngine = require('./buildTaskEngine')
const Plugin = require('./plugin')
const { BuildError } = require('./util')

module.exports = { build, register, Plugin, BuildError }

// reuse schema definition from cds-rc.js used for package.json code completion
/** @typedef{import('../env/schemas/cds-rc')['$defs']['buildTaskType']['enum'][number]} BuildFor */

// using (string & {}) prevents widening of `'x' | string` to just `string`
/**
 * @typedef {{
 *  clean?: boolean,
 *  outputMode?: number,
 *  for?: BuildFor | (string & {}),
 *  src?: string,
 *  dest?: string,
 *  model?: string[],
 *  root?: string = cds.root,
 * } & {[key:string]:unknown}} BuildOptions
 */

/**
 * Executes cds build with specified options.
 *
 * @param {BuildOptions} options - command options
 */
async function build({ root = cds.root, ...options } = {}) {
    if (!exists(root) || !isdir(root)) {
        throw `Project folder '${root}' does not exist`
    }
    try {
        return await new BuildTaskEngine(options).processTasks()
    } catch (e) {
        if (e instanceof BuildError || e.constructor.name === 'CompilationError') {
            cds._log(e.messages.length ? e.messages : e.message, { 'log-level': options['log-level'] || cds.env['log-level'] })
            console.log()
            // CompilationError.message also includes the detail messages - do not log twice
            throw e.constructor.name === 'CompilationError' ? 'CDS compilation failed' : e.messages.length ? e.message : 'CDS build failed'
        }
        throw e
    }
}

function register(id, plugin) {
    return require('./plugins').register(id, plugin)
}
