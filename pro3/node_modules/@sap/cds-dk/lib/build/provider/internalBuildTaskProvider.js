const cds = require('../../cds')
const { exists, isdir, path } = cds.utils
const { hasJavaNature, BuildError, normalizePath } = require('../util')
const BuildTaskProvider = require('../buildTaskProvider')
const { FILE_EXT_CDS, BUILD_TASK_HANA, BUILD_TASK_FIORI, BUILD_TASK_JAVA, BUILD_TASK_JAVA_CF, BUILD_TASK_NODEJS, BUILD_TASK_NODE_CF, BUILD_TASK_MTX,
    BUILD_TASKS, BUILD_TASK_MTX_SIDECAR, MTX_SIDECAR_FOLDER, BUILD_TASK_MTX_EXTENSION } = require("../constants")
const ResourcesTarBuilder = require('./mtx/resourcesTarBuilder')
const DEBUG = cds.debug('cli|build')
const ModelProviderService = 'cds.xt.ModelProviderService'

module.exports = class InternalBuildTaskProvider extends BuildTaskProvider {
    providesTask(key) {
        return BUILD_TASKS.includes(key.for)
    }

    async lookupTasks(tasks, dependencies) {
        return this._createTasks(tasks, dependencies)
    }

    async applyTaskDefaults(task) {
        InternalBuildTaskProvider._setDefaultSrcFolder(task)
    }

    getPlugin(task) {
        return require(`./${task.for}`)
    }

    async _createTasks(tasks, dependencies) {
        let db = typeof cds.env.folders.db === "string" ? [normalizePath(cds.env.folders.db)] : cds.env.folders.db
        let srv = typeof cds.env.folders.srv === "string" ? [normalizePath(cds.env.folders.srv)] : cds.env.folders.srv

        const folder4 = filesOrFolders => {
            const entry = filesOrFolders
                .flatMap(r => path.extname(r) === FILE_EXT_CDS ? [r] : [r, r + FILE_EXT_CDS])
                .find(r => exists(r))
            return entry && (isdir(entry) ? entry : path.dirname(entry))
        }
        const dbOptions = { model: [] }
        const srvOptions = { model: [] }
        if (Array.isArray(db) && db.length > 0) {
            db = folder4(db)
            if (!db && !dependencies) { // log once
                DEBUG?.("No database module found")
            }
        }
        if (Array.isArray(srv) && srv.length > 0) {
            srv = folder4(srv)
            if (!srv && !dependencies) { // log once
                DEBUG?.("No service module found")
            }
        }

        // order of creation is relevant
        if (dependencies) {
            const mtxTask = tasks.find(task => task.for === BUILD_TASK_MTX || task.for === BUILD_TASK_MTX_SIDECAR)
            if (mtxTask) {
                //restore used tasks as they might have been filtered by 'cds build --for mtx'
                if (mtxTask._uses) {
                    mtxTask._uses.map(use => use.task).forEach(task => {
                        if (!tasks.includes(task)) {
                            tasks.push(task)
                        }
                    })
                }
                let dbTask = ResourcesTarBuilder.getHanaTenantDbTask(tasks, mtxTask)
                if (!dbTask) {
                    //  db task might be missing if mtx task is enforced by 'cds build --for mtx'
                    if (cds.env.build.tasks) {
                        dbTask = ResourcesTarBuilder.getHanaTenantDbTask(cds.env.build.tasks, mtxTask)
                    }
                    if (!dbTask) {
                        dbTask = this._createDbTask(db, dbOptions)
                    }
                    if (dbTask) {
                        tasks.push(dbTask)
                    }
                }
                if (dbTask && !mtxTask._uses?.map(use => use.task).includes(dbTask)) {
                    const use = { task: dbTask }
                    mtxTask._uses ? mtxTask._uses.push(use) : mtxTask._uses = [use]
                }
            }
        } else {
            !db && DEBUG?.(`project doesn't have a database module '${cds.env.folders.db}'`)
            !srv && DEBUG?.(`project doesn't have a service module '${cds.env.folders.srv}'`)

            // create hana build task
            const dbTask = this._createDbTask(db, dbOptions)
            if (dbTask) {
                tasks.push(dbTask)
            }
            // create java or node build task
            const srvTask = this._createSrvTask(srv, srvOptions)
            if (srvTask) {
                tasks.push(srvTask)
            }

            // create mtx build task
            const mtxTask = this._createMtxTask(srv)
            if (mtxTask) {
                tasks.push(mtxTask)
            }
        }
    }

    _createDbTask(src, taskOptions) {
        if (!src || InternalBuildTaskProvider._isMtxExtension()) {
            return null
        }
        let task = null
        if (this._useHana()) {
            DEBUG?.("found HANA database")
            task = {
                src: src,
                for: BUILD_TASK_HANA,
                options: taskOptions
            }
        } else {
            DEBUG?.("found sqlite database - skipping HANA build task")
        }
        return task
    }

    _useHana() {
        if (cds.env.requires.db?.kind === "hana" || cds.env.requires.db?.dialect === "hana") {
            return true
        }
        // false if other db has been defined
        if (cds.env.requires.db?.kind) {
            return false
        }
    }

    _createMtxTask(src) {
        const main = cds.env
        if (main.extends) {
            return { for: BUILD_TASK_MTX_EXTENSION }
        }
        const isMtxs = main.requires.toggles || main.requires.multitenancy || main.requires[ModelProviderService]
        if (isMtxs) {
            if (main.requires?.[ModelProviderService]?._in_sidecar) {
                throw new BuildError(`Seems that you are executing 'cds build' in the 'mtx/sidecar' folder. Execute 'cds build' in the project root folder instead.`)
            }
            const sidecarPath = path.join(cds.root, MTX_SIDECAR_FOLDER)
            const sidecar = cds.env.for("cds", sidecarPath)
            if (sidecar?.requires[ModelProviderService]?._in_sidecar) {
                if (!exists(sidecarPath)) {
                    throw new BuildError(`MTX sidecar directory '${MTX_SIDECAR_FOLDER}' does not exist. Custom build task configuration required if the folder is named differently.`)
                }
                return { src: MTX_SIDECAR_FOLDER, for: BUILD_TASK_MTX_SIDECAR }
            }
            if (!hasJavaNature()) { // only Node.js: embedded multitenancy
                return { src, for: BUILD_TASK_MTX }
            }
        }
    }

    _createSrvTask(src, taskOptions) {
        if (!src || InternalBuildTaskProvider._isMtxExtension()) {
            return null
        }
        let task = null
        if (hasJavaNature()) {
            task = this._createJavaTask(src, taskOptions)
        } else {
            task = this._createNodeTask(src, taskOptions)
        }
        return task
    }

    _createJavaTask(src, taskOptions) {
        DEBUG?.("found Java runtime")
        return {
            src: src,
            for: BUILD_TASK_JAVA,
            options: taskOptions
        }
    }

    _createNodeTask(src, taskOptions) {
        DEBUG?.("found Nodejs runtime")
        if (!exists('package.json')) {
            throw new BuildError(`No 'package.json' found in project root folder '${cds.root}'`)
        }
        return {
            src: src,
            for: BUILD_TASK_NODEJS,
            options: taskOptions
        }
    }

    static _isMtxExtension() {
        return !!cds.env.extends
    }

    static _setDefaultSrcFolder(task) {
        switch (task.for) {
            case BUILD_TASK_HANA:
                task.src ||= normalizePath(cds.env.folders.db)
                break
            case BUILD_TASK_JAVA:
            case BUILD_TASK_JAVA_CF:
            case BUILD_TASK_NODEJS:
            case BUILD_TASK_NODE_CF:
                task.src ||= normalizePath(cds.env.folders.srv)
                break
            case BUILD_TASK_FIORI:
                task.src ||= normalizePath(cds.env.folders.app)
                break
            case BUILD_TASK_MTX_SIDECAR:
                task.src ||= MTX_SIDECAR_FOLDER
                break
            case BUILD_TASK_MTX_EXTENSION:
                if (task.src && task.src !== cds.root) {
                    throw new BuildError("Invalid 'src' property value for build task 'mtx-extension', the only allowed value is '.'")
                }
                task.src ||= "."
                break
            case BUILD_TASK_MTX:
                // mtxs with nodejs, but without sidecar
                task.src ||= normalizePath(cds.env.folders.srv)
                break
            default:
                throw new Error(`Unknown build task '${task.for}'`)
        }
    }
}
